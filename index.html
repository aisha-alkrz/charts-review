<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Charts Page</title>
    <!-- Include Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include D3.js library for drawing charts -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Global styling and font import */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e2e8f0; /* Light gray background */
            color: #1a202c; /* Dark text color */
        }

        /* Styling for the active button */
        .active-button {
            @apply bg-blue-600 text-white shadow-lg transform scale-105;
        }

        /* Ensure active button doesn't change on hover/focus */
        .tab-button.active-button:hover,
        .tab-button.active-button:focus {
            @apply bg-blue-600 text-white; /* Keep the active style */
            transform: scale(1.05); /* Maintain transform */
        }

        /* Styling for inactive buttons to ensure consistent appearance */
        .tab-button:not(.active-button) {
            @apply bg-gray-200 text-gray-700;
        }

        .tab-button:not(.active-button):hover {
            @apply bg-gray-300;
        }

        .tab-button:not(.active-button):focus {
            @apply ring-4 ring-gray-300;
        }

        /* Chart tooltip styling */
        .chart-tooltip {
            position: absolute;
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
        }
        
        /* Styling for the JSON code display */
        .json-editor-pre {
            background-color: #1f2937;
            border-radius: 0.5rem;
            padding: 1rem;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 450px;
            overflow-y: auto;
            font-size: 0.875rem;
            line-height: 1.2;
            color: #d1d5db; /* Light gray text */
        }

        /* Responsive chart containers - removed aspect-ratio to allow dimensions from mapping to control size */
        .chart-container {
            width: 100%; /* Will be overridden by SVG width if specified */
            height: auto; /* Will be overridden by SVG height if specified */
            display: flex; /* Ensures content is centered */
            align-items: center;
            justify-content: center;
        }

        /* Specific styling for the waffle chart grid */
        .waffle-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            aspect-ratio: 1 / 1;
            width: 100%;
        }

        .waffle-square {
            transition: background-color 0.2s ease-in-out;
            aspect-ratio: 1 / 1;
        }
    </style>
</head>
<body>

    <!-- Main container for layout -->
    <div class="max-w-7xl mx-auto bg-white p-8 rounded-3xl shadow-2xl space-y-8 my-8">

        <!-- Page title -->
        <h1 class="text-3xl md:text-4xl font-bold text-center text-gray-800">
            Interactive Charts Page
        </h1>

        <!-- Buttons container -->
        <div class="flex flex-col md:flex-row justify-center items-center space-y-4 md:space-y-0 md:space-x-4">
            <button id="button1" data-target="section1" class="tab-button w-full md:w-auto px-8 py-3 rounded-xl transition duration-300 ease-in-out font-semibold text-lg text-white bg-blue-500 hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300 shadow-md">
                Charts Set 1
            </button>
            <button id="button2" data-target="section3" class="tab-button w-full md:w-auto px-8 py-3 rounded-xl transition duration-300 ease-in-out font-semibold text-lg text-gray-700 bg-gray-200 hover:bg-gray-300 focus:outline-none focus:ring-4 focus:ring-gray-300 shadow-md">
                Charts Set 2
            </button>
        </div>

        <!-- Sections for charts -->
        <div class="space-y-6">
            <!-- Section 1: Bar, Dot, Pie, and Waffle Charts -->
            <div id="section1" class="tab-content hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 p-6 border-2 border-dashed border-gray-300 rounded-2xl bg-gray-50">
                    <div class="bg-white p-6 rounded-lg shadow-md w-full">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Bar Chart</h3>
                        <div id="barChartContainer" class="chart-container"></div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Dot Plot</h3>
                        <div id="dotPlotContainer" class="chart-container"></div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full flex flex-col items-center">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Pie Chart</h3>
                        <div class="flex flex-col md:flex-row items-center justify-center w-full space-y-4 md:space-y-0 md:space-x-8">
                            <div id="pieChartContainer" class="w-full flex justify-center items-center aspect-square"></div>
                            <div id="pieChartLegend" class="flex flex-col space-y-2 text-sm text-gray-700"></div>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full flex flex-col items-center">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Waffle Chart</h3>
                        <div class="flex flex-col items-center justify-center w-full">
                            <div id="waffleChartContainer" class="waffle-grid max-w-xs"></div>
                            <div id="waffleChartLegend" class="flex flex-col space-y-2 text-sm text-gray-700 mt-4"></div>
                        </div>
                    </div>
                </div>
                <div class="mt-6 text-center">
                    <button onclick="toggleMapping('mapping-display-1-wrapper')" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm shadow">Show Data Mapping</button>
                </div>
                <div id="mapping-display-1-wrapper" class="hidden mt-4 transition-all duration-300 ease-in-out">
                    <pre class="json-editor-pre max-w-3xl mx-auto"><code id="mapping-display-1" class="language-json"></code></pre>
                </div>
            </div>

            <!-- Section 2 is removed as per user request -->
            <!-- <div id="section2" class="tab-content hidden">...</div> -->

            <!-- Section 3: Stacked Bar Chart and Line Chart -->
            <div id="section3" class="tab-content hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 p-6 border-2 border-dashed border-gray-300 rounded-2xl bg-gray-50">
                    <div class="bg-white p-6 rounded-lg shadow-md w-full">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Stacked Bar Chart</h3>
                        <div id="stackedBarChartContainer" class="chart-container"></div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Stacked Area Chart</h3>
                        <div id="stackedAreaChartContainer" class="chart-container"></div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Grouped Bar Chart</h3>
                        <div id="groupedBarChartContainer" class="chart-container"></div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Line Chart</h3>
                        <div id="lineChartContainer" class="chart-container"></div>
                    </div>
                </div>
                <div class="mt-6 text-center">
                    <button onclick="toggleMapping('mapping-display-3-wrapper')" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm shadow">Show Data Mapping</button>
                </div>
                <div id="mapping-display-3-wrapper" class="hidden mt-4 transition-all duration-300 ease-in-out">
                    <pre class="json-editor-pre max-w-3xl mx-auto"><code id="mapping-display-3" class="language-json"></code></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Data and configuration for the charts
        const chartConfig1 = {
            "mapping": {
                "dimensions": { "width": 500, "height": 350 },
                "type": ["bar-chart", "dot-plot", "pie-chart", "waffle-chart"], // All types in one config
                "key1": { "value": "month", "label": "Month" },
                "key2": { "value": "sales", "label": "Sales" },
                "key3": [
                    { "value": "month", "label": "Month" },
                    { "value": "sales", "label": "Sales", "format": "$0,0" },
                    { "value": "region", "label": "Region" }
                ],
                "colors": ["#4e79a7", "#f28e2c", "#e15759", "#76b7b2", "#59a14f", "#edc948", "#af7aa1", "#ff9da7", "#9c755f", "#bab0ab"] // Added more colors
            },
            "data": [
                { "month": "January", "sales": 8000, "region": "East" },
                { "month": "February", "sales": 2000, "region": "West" },
                { "month": "March", "sales": 4000, "region": "North" }
            ]
        };

        // chartConfig2 is removed as its functionality is merged into chartConfig1
        // const chartConfig2 = { ... };

        const chartConfig3 = {
            "mapping": {
                "dimensions": { "width": 500, "height": 350 },
                "type": ["stacked-bar-chart", "stacked-area-chart", "grouped-bar-chart", "line-chart"], // All types are back
                "key1": { "value": "month", "label": "Month" },
                "key2": { "value": "sales", "label": "Total Sales" },
                "key3": { "value": "product", "label": "Product" },
                "key4": [
                    { "value": "month", "label": "Month" },
                    { "value": "product", "label": "Product" },
                    { "value": "sales", "label": "Sales", "format": "$0,0" }
                ],
                "colors": ["#8dd3c7", "#bebada", "#fb8072", "#80b1d3"] 
            },
            "data": [
                {"month": "January", "product": "Product A", "sales": 12000},
                {"month": "January", "product": "Product B", "sales": 8000},
                {"month": "January", "product": "Product C", "sales": 5000},
                {"month": "February", "product": "Product A", "sales": 15000},
                {"month": "February", "product": "Product B", "sales": 10000},
                {"month": "February", "product": "Product C", "sales": 6000},
                {"month": "March", "product": "Product A", "sales": 18000},
                {"month": "March", "product": "Product B", "sales": 12000},
                {"month": "March", "product": "Product C", "sales": 7000}
            ]
        };
        
        // This variable will hold a single tooltip element for all charts
        let tooltip = null;

        // Helper function to format numbers based on a specified format string
        function formatNumber(value, format) {
            if (!format) return value;
            if (format.includes('$')) {
                return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0 }).format(value);
            }
            return value;
        }

        // Main function to dynamically generate tooltip content from a data object and an array of tooltip keys
        function generateTooltipContent(dataObject, tooltipKeys) {
            let html = '';
            tooltipKeys.forEach(keyConfig => {
                const value = dataObject[keyConfig.value];
                const formattedValue = formatNumber(value, keyConfig.format);
                html += `<div><strong>${keyConfig.label}</strong>: ${formattedValue}</div>`;
            });
            return html;
        }
        
        // --- D3.js Chart Functions ---
        // Helper function to get or create a new tooltip element
        function getOrCreateTooltip() {
            if (!tooltip) {
                tooltip = d3.select("body").append("div")
                    .attr("class", "chart-tooltip");
            }
            return tooltip;
        }
        
        // Function to create a Bar Chart
        function createBarChart(config) {
            const containerId = 'barChartContainer';
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();
            
            // Get dimensions and keys from the mapping configuration
            const chartWidth = config.mapping.dimensions.width;
            const chartHeight = config.mapping.dimensions.height;
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            const xKey = config.mapping.key1.value;
            const yKey = config.mapping.key2.value;
            const tooltipKeys = config.mapping.key3;

            const svg = container
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scaleBand()
                .domain(config.data.map(d => d[xKey]))
                .range([0, width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(config.data, d => d[yKey])])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal(config.mapping.colors); // Use colors from config.mapping
            const chartTooltip = getOrCreateTooltip();

            svg.append('g')
                .selectAll('rect')
                .data(config.data)
                .join('rect')
                .attr('x', d => x(d[xKey]))
                .attr('y', d => y(d[yKey]))
                .attr('height', d => height - y(d[yKey]))
                .attr('width', x.bandwidth())
                .attr('fill', (d, i) => color(i))
                .on("mouseover", function(event, d) {
                    chartTooltip.style("opacity", 1)
                        .html(generateTooltipContent(d, tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0);
                });

            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to create a Dot Plot
        function createDotPlot(config) {
            const containerId = 'dotPlotContainer';
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();
            
            // Get dimensions and keys from the mapping configuration
            const chartWidth = config.mapping.dimensions.width;
            const chartHeight = config.mapping.dimensions.height;
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            const xKey = config.mapping.key1.value;
            const yKey = config.mapping.key2.value;
            const tooltipKeys = config.mapping.key3;

            const svg = container
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scalePoint()
                .domain(config.data.map(d => d[xKey]))
                .range([0, width])
                .padding(0.5);

            const y = d3.scaleLinear()
                .domain([0, d3.max(config.data, d => d[yKey])])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal(config.mapping.colors); // Use colors from config.mapping
            const chartTooltip = getOrCreateTooltip();

            svg.append('g')
                .selectAll('circle')
                .data(config.data)
                .join('circle')
                .attr('cx', d => x(d[xKey]))
                .attr('cy', d => y(d[yKey]))
                .attr('r', 5)
                .attr('fill', (d, i) => color(i))
                .on("mouseover", function(event, d) {
                    chartTooltip.style("opacity", 1)
                        .html(generateTooltipContent(d, tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0);
                });

            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to create a Pie Chart
        function createPieChart(config) {
            const containerId = 'pieChartContainer';
            const legendId = 'pieChartLegend';
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();
            d3.select(`#${legendId}`).selectAll('*').remove();

            // Get dimensions and keys from the mapping configuration
            const chartWidth = config.mapping.dimensions.width;
            const chartHeight = config.mapping.dimensions.height;
            const sizeKey = config.mapping.key2.value; // For pie/waffle, sales is the size
            const labelKey = config.mapping.key1.value; // For pie/waffle, month is the label
            const tooltipKeys = config.mapping.key3;
            const size = Math.min(chartWidth, chartHeight); 
            const radius = size / 2;
            const innerRadius = radius * 0;

            const svg = container
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight)
                .append('g')
                .attr('transform', `translate(${chartWidth / 2},${chartHeight / 2})`); 

            // Use colors from the config
            const color = d3.scaleOrdinal()
                .domain(config.data.map(d => d[labelKey]))
                .range(config.mapping.colors);

            const pie = d3.pie()
                .value(d => d[sizeKey])
                .sort(null);

            const arc = d3.arc()
                .innerRadius(innerRadius)
                .outerRadius(radius);

            const chartTooltip = getOrCreateTooltip();

            // Create the arcs
            svg.selectAll('path')
                .data(pie(config.data))
                .join('path')
                .attr('d', arc)
                .attr('fill', d => color(d.data[labelKey]))
                .attr('stroke', 'white')
                .style('stroke-width', '2px')
                .on("mouseover", function(event, d) {
                    d3.select(this).transition().duration(100).style('opacity', 0.8);
                    chartTooltip.style("opacity", 1)
                        .html(generateTooltipContent(d.data, tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this).transition().duration(100).style('opacity', 1);
                    chartTooltip.style("opacity", 0);
                });

            // Add legend
            const legend = d3.select(`#${legendId}`);
            const legendItem = legend.selectAll('.legend-item')
                .data(config.data)
                .join('div')
                .attr('class', 'legend-item flex items-center');

            legendItem.append('div')
                .style('width', '12px')
                .style('height', '12px')
                .style('background-color', d => color(d[labelKey]))
                .style('border-radius', '2px');

            legendItem.append('span')
                .text(d => d[labelKey]);
        }

        // Function to create a Waffle Chart
        function createWaffleChart(config) {
            const containerId = 'waffleChartContainer';
            const legendId = 'waffleChartLegend';
            d3.select(`#${containerId}`).selectAll('*').remove();
            d3.select(`#${legendId}`).selectAll('*').remove();
            
            // Get keys from the mapping configuration
            const chartWidth = config.mapping.dimensions.width;
            const chartHeight = config.mapping.dimensions.height;
            const sizeKey = config.mapping.key2.value; // For pie/waffle, sales is the size
            const labelKey = config.mapping.key1.value; // For pie/waffle, month is the label
            const tooltipKeys = config.mapping.key3;
            
            const totalSales = d3.sum(config.data, d => d[sizeKey]);
            const totalSquares = 100;
            let dataForWaffle = [];

            config.data.forEach(d => {
                const percentage = (d[sizeKey] / totalSales) * 100;
                const numSquares = Math.round(percentage / 100 * totalSquares);
                for (let i = 0; i < numSquares; i++) {
                    dataForWaffle.push(d);
                }
            });

            // Fill empty squares if needed
            while (dataForWaffle.length < totalSquares) {
                dataForWaffle.push(null);
            }

            const color = d3.scaleOrdinal()
                .domain(config.data.map(d => d[labelKey]))
                .range(config.mapping.colors);
            
            const chartTooltip = getOrCreateTooltip();

            // Create waffle grid squares
            d3.select(`#${containerId}`)
                .style('width', `${chartWidth}px`)
                .style('height', `${chartHeight}px`)
                .selectAll('.waffle-square')
                .data(dataForWaffle)
                .join('div')
                .attr('class', 'waffle-square transition-colors duration-200 ease-in-out')
                .style('background-color', d => d ? color(d[labelKey]) : '#e2e8f0')
                .on("mouseover", function(event, d) {
                    if (d) {
                        chartTooltip.style("opacity", 1)
                            .html(generateTooltipContent(d, tooltipKeys))
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    }
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0);
                });

            // Add legend
            const legend = d3.select(`#${legendId}`);
            const legendItem = legend.selectAll('.legend-item')
                .data(config.data)
                .join('div')
                .attr('class', 'legend-item flex items-center space-x-2');

            legendItem.append('div')
                .style('width', '12px')
                .style('height', '12px')
                .style('background-color', d => color(d[labelKey]))
                .style('border-radius', '2px');

            legendItem.append('span')
                .text(d => d[labelKey]);
        }

        // Helper function to transform the data for stacked and grouped charts
        function transformDataForStacking(data, xKey, seriesKey, yKey) {
            const groupedData = d3.group(data, d => d[xKey]);
            const seriesKeys = Array.from(new Set(data.map(d => d[seriesKey]))).sort(); // Ensure series keys are sorted for consistent stacking
            const transformedData = [];

            groupedData.forEach((values, key) => {
                const newObject = { [xKey]: key };
                seriesKeys.forEach(sKey => {
                    const item = values.find(v => v[seriesKey] === sKey);
                    newObject[sKey] = item ? item[yKey] : 0;
                });
                transformedData.push(newObject);
            });

            return { transformedData, seriesKeys };
        }

        // Function to create a Stacked Bar Chart
        function createStackedBarChart(config) {
            const containerId = 'stackedBarChartContainer';
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();

            // Get dimensions and keys from the mapping configuration
            const chartWidth = config.mapping.dimensions.width;
            const chartHeight = config.mapping.dimensions.height;
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            const xKey = config.mapping.key1.value;
            const seriesKey = config.mapping.key3.value;
            const yKey = config.mapping.key2.value; 
            const tooltipKeys = config.mapping.key4;
            
            // Transform data for stacking
            const { transformedData, seriesKeys } = transformDataForStacking(config.data, xKey, seriesKey, yKey); 

            // Stack the transformed data
            const series = d3.stack()
                .keys(seriesKeys)
                .value((d, key) => d[key])
                (transformedData);

            const svg = container
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const x = d3.scaleBand()
                .domain(transformedData.map(d => d[xKey]))
                .range([0, width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(series, d => d3.max(d, e => e[1]))])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(seriesKeys)
                .range(config.mapping.colors);
            
            const chartTooltip = getOrCreateTooltip();

            svg.append('g')
                .selectAll('g')
                .data(series)
                .join('g')
                .attr('fill', d => color(d.key))
                .selectAll('rect')
                .data(d => d)
                .join('rect')
                .attr('x', d => x(d.data[xKey]))
                .attr('y', d => y(d[1]))
                .attr('height', d => y(d[0]) - y(d[1]))
                .attr('width', x.bandwidth())
                .on("mouseover", function(event, d) {
                    const dataPoint = {
                        [xKey]: d.data[xKey],
                        [seriesKey]: d3.select(this.parentNode).datum().key,
                        [yKey]: d[1] - d[0] // Calculate the individual segment's value
                    };
                    chartTooltip.style("opacity", 1)
                        .html(generateTooltipContent(dataPoint, tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0);
                });

            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to create a Stacked Area Chart
        function createStackedAreaChart(config) {
            const containerId = 'stackedAreaChartContainer';
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();

            // Get dimensions and keys from the mapping configuration
            const chartWidth = config.mapping.dimensions.width;
            const chartHeight = config.mapping.dimensions.height;
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            const xKey = config.mapping.key1.value;
            const seriesKey = config.mapping.key3.value;
            const yKey = config.mapping.key2.value; 
            const tooltipKeys = config.mapping.key4;
            
            // Transform data for stacking
            const { transformedData, seriesKeys } = transformDataForStacking(config.data, xKey, seriesKey, yKey); 

            // Stack the transformed data
            const series = d3.stack()
                .keys(seriesKeys)
                .value((d, key) => d[key])
                (transformedData);

            const svg = container
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scalePoint()
                .domain(transformedData.map(d => d[xKey]))
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(series, d => d3.max(d, e => e[1]))])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(seriesKeys)
                .range(config.mapping.colors);

            const area = d3.area()
                .x(d => x(d.data[xKey]))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]));

            const chartTooltip = getOrCreateTooltip();

            svg.append('g')
                .selectAll('path')
                .data(series)
                .join('path')
                .attr('fill', d => color(d.key))
                .attr('d', area)
                .on("mouseover", function(event, d) {
                    const seriesTotal = d3.sum(d, p => p[1] - p[0]); 

                    chartTooltip.style("opacity", 1)
                        .html(`<div><strong>${config.mapping.key3.label}</strong>: ${d.key}</div>
                               <div><strong>${config.mapping.key2.label}</strong>: ${formatNumber(seriesTotal, "$0,0")}</div>`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0);
                });

            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to create a Grouped Bar Chart
        function createGroupedBarChart(config) {
            const containerId = 'groupedBarChartContainer';
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();

            // Get dimensions and keys from the mapping configuration
            const chartWidth = config.mapping.dimensions.width;
            const chartHeight = config.mapping.dimensions.height;
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            const xKey = config.mapping.key1.value;
            const yKey = config.mapping.key2.value;
            const seriesKey = config.mapping.key3.value;
            const tooltipKeys = config.mapping.key4;
            
            const svg = container
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const x0 = d3.scaleBand()
                .domain(Array.from(new Set(config.data.map(d => d[xKey]))))
                .range([0, width])
                .paddingInner(0.1);

            const x1 = d3.scaleBand()
                .domain(Array.from(new Set(config.data.map(d => d[seriesKey]))))
                .range([0, x0.bandwidth()])
                .padding(0.05);

            const y = d3.scaleLinear()
                .domain([0, d3.max(config.data, d => d[yKey])])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(Array.from(new Set(config.data.map(d => d[seriesKey]))))
                .range(config.mapping.colors);

            const chartTooltip = getOrCreateTooltip();

            const groupedData = d3.group(config.data, d => d[xKey]);

            svg.append('g')
                .selectAll('g')
                .data(Array.from(groupedData))
                .join('g')
                .attr('transform', d => `translate(${x0(d[0])},0)`)
                .selectAll('rect')
                .data(d => d[1])
                .join('rect')
                .attr('x', d => x1(d[seriesKey]))
                .attr('y', d => y(d[yKey]))
                .attr('width', x1.bandwidth())
                .attr('height', d => height - y(d[yKey]))
                .attr('fill', d => color(d[seriesKey]))
                .on("mouseover", function(event, d) {
                    chartTooltip.style("opacity", 1)
                        .html(generateTooltipContent(d, tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0);
                });
            
            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0));

            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to create a Line Chart
        function createLineChart(config) {
            const containerId = 'lineChartContainer';
            const container = d3.select(`#${containerId}`);
            container.selectAll('*').remove();

            const chartWidth = config.mapping.dimensions.width;
            const chartHeight = config.mapping.dimensions.height;
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            const xKey = config.mapping.key1.value;
            const yKey = config.mapping.key2.value;
            const seriesKey = config.mapping.key3.value;
            const tooltipKeys = config.mapping.key4;

            const svg = container
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Group data by seriesKey for multiple lines
            const dataGroupedBySeries = d3.group(config.data, d => d[seriesKey]);
            const seriesNames = Array.from(dataGroupedBySeries.keys());
            const xDomain = Array.from(new Set(config.data.map(d => d[xKey]))).sort(); 

            const x = d3.scalePoint()
                .domain(xDomain)
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(config.data, d => d[yKey])])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(seriesNames)
                .range(config.mapping.colors);

            const line = d3.line()
                .x(d => x(d[xKey]))
                .y(d => y(d[yKey]));

            const chartTooltip = getOrCreateTooltip();

            // Draw lines for each series
            svg.selectAll(".line")
                .data(dataGroupedBySeries)
                .join("path")
                .attr("fill", "none")
                .attr("stroke", d => color(d[0])) 
                .attr("stroke-width", 2.5)
                .attr("d", d => line(d[1].sort((a, b) => xDomain.indexOf(a[xKey]) - xDomain.indexOf(b[xKey])))); 

            // Add circles for each data point
            svg.selectAll(".dot")
                .data(config.data)
                .join("circle")
                .attr("class", "dot")
                .attr("cx", d => x(d[xKey]))
                .attr("cy", d => y(d[yKey]))
                .attr("r", 4)
                .attr("fill", d => color(d[seriesKey]))
                .attr("stroke", "white")
                .attr("stroke-width", 1.5)
                .on("mouseover", function(event, d) {
                    chartTooltip.style("opacity", 1)
                        .html(generateTooltipContent(d, tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0);
                });

            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to render charts for the active section
        function renderChartsForSection(sectionId) {
            // Get all chart containers in the active section
            const containers = document.querySelectorAll(`#${sectionId} .chart-container, #${sectionId} .waffle-grid`);
            containers.forEach(container => {
                // Remove existing SVG to prevent duplicates
                d3.select(container).selectAll('*').remove();
            });

            switch (sectionId) {
                case 'section1':
                    createBarChart(chartConfig1);
                    createDotPlot(chartConfig1);
                    createPieChart(chartConfig1); 
                    createWaffleChart(chartConfig1); 
                    break;
                case 'section3':
                    createStackedBarChart(chartConfig3);
                    createStackedAreaChart(chartConfig3); 
                    createGroupedBarChart(chartConfig3); 
                    createLineChart(chartConfig3); 
                    break;
            }
        }
        
        // Function to set up tabs and event listeners
        function setupTabs() {
            const tabs = document.querySelectorAll('.tab-button');
            const contents = document.querySelectorAll('.tab-content');

            tabs.forEach(button => {
                button.addEventListener('click', () => {
                    const targetId = button.dataset.target;

                    // Remove active class from all buttons and add to the current button
                    tabs.forEach(btn => {
                        btn.classList.remove('active-button');
                        // Ensure inactive buttons revert to default Tailwind styles
                        btn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300', 'focus:ring-gray-300');
                        btn.classList.remove('bg-blue-600', 'text-white', 'shadow-lg', 'transform', 'scale-105', 'focus:ring-blue-300');
                    });
                    
                    button.classList.add('active-button');
                    // Ensure active button uses its specific styles
                    button.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300', 'focus:ring-gray-300');
                    button.classList.add('bg-blue-600', 'text-white', 'shadow-lg', 'transform', 'scale-105', 'focus:ring-blue-300');


                    // Hide all content and show only the target content
                    contents.forEach(content => content.classList.add('hidden'));
                    document.getElementById(targetId).classList.remove('hidden');

                    // Render charts for the active section
                    renderChartsForSection(targetId);
                });
            });

            // Click the first button on initial load
            document.getElementById('button1').click();
        }

        // Function to toggle the display of the JSON mapping
        function toggleMapping(wrapperId) {
            const wrapper = document.getElementById(wrapperId);
            wrapper.classList.toggle('hidden');
        }
        
        // Redraw charts on window resize to ensure responsiveness
        function handleResize() {
            const activeTab = document.querySelector('.tab-content:not(.hidden)');
            if (activeTab) {
                renderChartsForSection(activeTab.id);
            }
        }

        // Initialize the app on window load
        window.onload = function() {
            const mappingJson1 = JSON.stringify(chartConfig1.mapping, null, 2);
            const mappingJson3 = JSON.stringify(chartConfig3.mapping, null, 2); 

            document.getElementById('mapping-display-1').textContent = mappingJson1;
            document.getElementById('mapping-display-3').textContent = mappingJson3;

            setupTabs();
            // Add event listener for window resizing
            window.addEventListener('resize', handleResize);
        };
    </script>
</body>
</html>
