<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Charts Page</title>
    <!-- Include Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include D3.js library for drawing charts -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Global styling and font import */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc; /* Light background color */
            color: #2d3748; /* Dark text color */
        }

        /* Styling for the active button */
        .active-button {
            @apply bg-blue-600 text-white shadow-lg transform scale-105;
        }

        /* Chart tooltip styling */
        .chart-tooltip {
            position: absolute;
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: opacity 0.2s;
            white-space: nowrap;
            display: none; /* Initially hidden */
        }
        
        /* JSON code display styling */
        .json-editor-pre {
            background-color: #1f2937;
            border-radius: 0.5rem;
            padding: 1rem;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 450px;
            overflow-y: auto;
            font-size: 0.875rem;
            line-height: 1.2;
            color: #d1d5db; /* Light gray text color */
        }

        /* Styles for chart containers to ensure they are responsive */
        .chart-container {
            width: 100%;
            height: 350px; /* Fixed height, but width is fluid */
        }

        /* Waffle chart specific styling for a 10x10 grid */
        .waffle-container {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            aspect-ratio: 1 / 1; /* Maintain a square aspect ratio */
            max-width: 300px;
        }
        .waffle-square {
            width: 100%;
            height: 100%;
            border-radius: 3px;
        }
    </style>
</head>
<body>

    <!-- Main container for the layout -->
    <div class="max-w-6xl mx-auto bg-white p-6 rounded-3xl shadow-2xl space-y-8 my-8">

        <!-- Page title -->
        <h1 class="text-3xl md:text-4xl font-bold text-center text-gray-800">
            Interactive Charts Page
        </h1>

        <!-- Buttons container -->
        <div class="flex flex-col md:flex-row justify-center items-center space-y-4 md:space-y-0 md:space-x-4">
            <button id="button1" data-target="section1" class="tab-button w-full md:w-auto px-6 py-3 rounded-xl transition duration-300 ease-in-out font-semibold text-lg text-white bg-blue-500 hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300 shadow-md">
                Set 1 (Bar & Dot)
            </button>
            <button id="button2" data-target="section2" class="tab-button w-full md:w-auto px-6 py-3 rounded-xl transition duration-300 ease-in-out font-semibold text-lg text-gray-700 bg-gray-200 hover:bg-gray-300 focus:outline-none focus:ring-4 focus:ring-gray-300 shadow-md">
                Set 2 (Pie & Waffle)
            </button>
            <button id="button3" data-target="section3" class="tab-button w-full md:w-auto px-6 py-3 rounded-xl transition duration-300 ease-in-out font-semibold text-lg text-gray-700 bg-gray-200 hover:bg-gray-300 focus:outline-none focus:ring-4 focus:ring-gray-300 shadow-md">
                Set 3 (Stacked & Grouped)
            </button>
        </div>

        <!-- Sections container for charts -->
        <div class="space-y-6">
            <!-- Section 1: Bar and Dot Charts -->
            <div id="section1" class="tab-content hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 p-4 border-2 border-dashed border-gray-300 rounded-2xl bg-gray-50 place-items-center">
                    <div class="bg-white p-6 rounded-lg shadow-md w-full max-w-lg">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Bar Chart</h3>
                        <div id="barChartContainer" class="chart-container"></div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full max-w-lg">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Dot Plot</h3>
                        <div id="dotPlotContainer" class="chart-container"></div>
                    </div>
                </div>
                <div class="mt-6 text-center">
                    <button onclick="toggleMapping('mapping-display-1-wrapper')" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded text-sm shadow">Show Data Mapping</button>
                </div>
                <div id="mapping-display-1-wrapper" class="hidden mt-4 transition-all duration-300 ease-in-out">
                    <pre class="json-editor-pre max-w-3xl mx-auto"><code id="mapping-display-1" class="language-json"></code></pre>
                </div>
            </div>

            <!-- Section 2: Pie and Waffle Charts -->
            <div id="section2" class="tab-content hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 p-4 border-2 border-dashed border-gray-300 rounded-2xl bg-gray-50 place-items-center">
                    <div class="bg-white p-6 rounded-lg shadow-md w-full max-w-lg flex flex-col items-center">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Pie Chart</h3>
                        <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-8 chart-container">
                            <div id="pieChartContainer" class="w-full h-full flex justify-center items-center"></div>
                            <div id="pieChartLegend" class="flex flex-col space-y-2 text-sm text-gray-700"></div>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full max-w-lg flex flex-col items-center">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Waffle Chart</h3>
                        <!-- Waffle chart container is a grid for better layout control -->
                        <div id="waffleChartContainer" class="waffle-container"></div>
                        <!-- Legend for the waffle chart -->
                        <div id="waffleChartLegend" class="flex flex-col space-y-2 text-sm text-gray-700 mt-4"></div>
                    </div>
                </div>
                <div class="mt-6 text-center">
                    <button onclick="toggleMapping('mapping-display-2-wrapper')" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded text-sm shadow">Show Data Mapping</button>
                </div>
                <div id="mapping-display-2-wrapper" class="hidden mt-4 transition-all duration-300 ease-in-out">
                    <pre class="json-editor-pre max-w-3xl mx-auto"><code id="mapping-display-2" class="language-json"></code></pre>
                </div>
            </div>

            <!-- Section 3: Stacked and Grouped Charts -->
            <div id="section3" class="tab-content hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 p-4 border-2 border-dashed border-gray-300 rounded-2xl bg-gray-50 place-items-center">
                    <div class="bg-white p-6 rounded-lg shadow-md w-full max-w-md">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Stacked Bar Chart</h3>
                        <div id="stackedBarChartContainer" class="chart-container"></div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full max-w-md">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Stacked Area Chart</h3>
                        <div id="stackedAreaChartContainer" class="chart-container"></div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md w-full max-w-md">
                        <h3 class="text-lg font-semibold mb-4 text-gray-700 text-center">Grouped Bar Chart</h3>
                        <div id="groupedBarChartContainer" class="chart-container"></div>
                    </div>
                </div>
                <div class="mt-6 text-center">
                    <button onclick="toggleMapping('mapping-display-3-wrapper')" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded text-sm shadow">Show Data Mapping</button>
                </div>
                <div id="mapping-display-3-wrapper" class="hidden mt-4 transition-all duration-300 ease-in-out">
                    <pre class="json-editor-pre max-w-3xl mx-auto"><code id="mapping-display-3" class="language-json"></code></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Chart data and configurations
        const chartConfig1 = {
            "mapping": {
                "type": ["bar-chart", "dot-plot"],
                "xKey": { "value": "month", "label": "Month" },
                "yKey": { "value": "sales", "label": "Sales" },
                "tooltipKeys": [
                    { "value": "month", "label": "Month" },
                    { "value": "sales", "label": "Sales", "format": "$0,0" },
                    { "value": "region", "label": "Region" }
                ]
            },
            "data": [
                { "month": "January", "sales": 28000, "region": "East" },
                { "month": "February", "sales": 32000, "region": "West" },
                { "month": "March", "sales": 40000, "region": "North" }
            ]
        };

        const chartConfig2 = {
            "mapping": {
                "type": ["pie-chart", "waffle-chart"],
                "sizeKey": { "value": "sales", "label": "Sales" },
                "labelKey": { "value": "region", "label": "Region" },
                "colors": ["#4e79a7", "#f28e2c", "#e15759"],
                "tooltipKeys": [
                    { "value": "month", "label": "Month" },
                    { "value": "sales", "label": "Sales", "format": "$0,0" }
                ]
            },
            "data": [
                { "month": "January", "sales": 28000, "region": "East" },
                { "month": "February", "sales": 32000, "region": "West" },
                { "month": "March", "sales": 40000, "region": "North" }
            ]
        };

        const chartConfig3 = {
            "mapping": {
                "type": ["stacked-bar-chart", "stacked-area-chart", "grouped-bar-chart"],
                "xKey": { "value": "month", "label": "Month" },
                "yKey": { "value": "sales", "label": "Total Sales" },
                "seriesKey": { "value": "product", "label": "Product" },
                "colors": ["#8dd3c7", "#bebada", "#fb8072"],
                "tooltipKeys": [
                    { "value": "month", "label": "Month" },
                    { "value": "product", "label": "Product" },
                    { "value": "sales", "label": "Sales", "format": "$0,0" }
                ]
            },
            "data": [
                {"month": "January", "product": "Product A", "sales": 12000},
                {"month": "January", "product": "Product B", "sales": 8000},
                {"month": "January", "product": "Product C", "sales": 5000},
                {"month": "February", "product": "Product A", "sales": 15000},
                {"month": "February", "product": "Product B", "sales": 10000},
                {"month": "February", "product": "Product C", "sales": 6000},
                {"month": "March", "product": "Product A", "sales": 18000},
                {"month": "March", "product": "Product B", "sales": 12000},
                {"month": "March", "product": "Product C", "sales": 7000}
            ]
        };
        
        // This variable will hold a single tooltip element for all charts
        let tooltip = null;

        // Helper function to format numbers based on a specified format string
        function formatNumber(value, format) {
            if (!format) return value;
            if (format.includes('$')) {
                return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0 }).format(value);
            }
            return value;
        }

        // Main function to generate tooltip content dynamically from a data object and a tooltip key array
        function generateTooltipContent(dataObject, tooltipKeys) {
            let html = '';
            tooltipKeys.forEach(keyConfig => {
                const value = dataObject[keyConfig.value];
                const formattedValue = formatNumber(value, keyConfig.format);
                html += `<div><strong>${keyConfig.label}</strong>: ${formattedValue}</div>`;
            });
            return html;
        }
        
        // --- D3.js Chart Functions ---
        // Helper function to create a new tooltip element or get the existing one
        function getOrCreateTooltip() {
            if (!tooltip) {
                tooltip = d3.select("body").append("div")
                    .attr("class", "chart-tooltip")
                    .style("position", "absolute")
                    .style("opacity", 0)
                    .style("display", "none");
            }
            return tooltip;
        }
        
        // Function to create a Bar Chart
        function createBarChart(config) {
            const containerId = 'barChartContainer';
            d3.select(`#${containerId}`).selectAll('*').remove();
            
            // Get the container dimensions to make the chart responsive
            const container = document.getElementById(containerId);
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scaleBand()
                .domain(config.data.map(d => d[config.mapping.xKey.value]))
                .range([0, width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(config.data, d => d[config.mapping.yKey.value])])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal(d3.schemeCategory10);
            const chartTooltip = getOrCreateTooltip();

            svg.append('g')
                .selectAll('rect')
                .data(config.data)
                .join('rect')
                .attr('x', d => x(d[config.mapping.xKey.value]))
                .attr('y', d => y(d[config.mapping.yKey.value]))
                .attr('height', d => height - y(d[config.mapping.yKey.value]))
                .attr('width', x.bandwidth())
                .attr('fill', (d, i) => color(i))
                .on("mouseover", function(event, d) {
                    chartTooltip.style("display", "block")
                        .style("opacity", 1)
                        .html(generateTooltipContent(d, config.mapping.tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0).style("display", "none");
                });

            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to create a Dot Plot
        function createDotPlot(config) {
            const containerId = 'dotPlotContainer';
            d3.select(`#${containerId}`).selectAll('*').remove();
            
            const container = document.getElementById(containerId);
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scalePoint()
                .domain(config.data.map(d => d[config.mapping.xKey.value]))
                .range([0, width])
                .padding(0.5);

            const y = d3.scaleLinear()
                .domain([0, d3.max(config.data, d => d[config.mapping.yKey.value])])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal(d3.schemeCategory10);
            const chartTooltip = getOrCreateTooltip();

            svg.append('g')
                .selectAll('circle')
                .data(config.data)
                .join('circle')
                .attr('cx', d => x(d[config.mapping.xKey.value]))
                .attr('cy', d => y(d[config.mapping.yKey.value]))
                .attr('r', 5)
                .attr('fill', (d, i) => color(i))
                .on("mouseover", function(event, d) {
                    chartTooltip.style("display", "block")
                        .style("opacity", 1)
                        .html(generateTooltipContent(d, config.mapping.tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0).style("display", "none");
                });

            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to create a Pie Chart
        function createPieChart(config) {
            const containerId = 'pieChartContainer';
            const legendId = 'pieChartLegend';
            d3.select(`#${containerId}`).selectAll('*').remove();
            d3.select(`#${legendId}`).selectAll('*').remove();

            const container = document.getElementById(containerId);
            const size = Math.min(container.clientWidth, container.clientHeight) * 0.9;
            const radius = size / 2;
            const innerRadius = radius * 0.6;

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', size)
                .attr('height', size)
                .append('g')
                .attr('transform', `translate(${size / 2},${size / 2})`);

            // Use the colors from the config
            const color = d3.scaleOrdinal()
                .domain(config.data.map(d => d[config.mapping.labelKey.value]))
                .range(config.mapping.colors);

            const pie = d3.pie()
                .value(d => d[config.mapping.sizeKey.value])
                .sort(null);

            const arc = d3.arc()
                .innerRadius(innerRadius)
                .outerRadius(radius);

            const chartTooltip = getOrCreateTooltip();

            // Create the arcs
            svg.selectAll('path')
                .data(pie(config.data))
                .join('path')
                .attr('d', arc)
                .attr('fill', d => color(d.data[config.mapping.labelKey.value]))
                .attr('stroke', 'white')
                .style('stroke-width', '2px')
                .on("mouseover", function(event, d) {
                    d3.select(this).transition().duration(100).style('opacity', 0.8);
                    chartTooltip.style("display", "block")
                        .style("opacity", 1)
                        .html(generateTooltipContent(d.data, config.mapping.tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this).transition().duration(100).style('opacity', 1);
                    chartTooltip.style("opacity", 0).style("display", "none");
                });

            // Add a legend
            const legend = d3.select(`#${legendId}`);
            const legendItem = legend.selectAll('.legend-item')
                .data(config.data)
                .join('div')
                .attr('class', 'legend-item flex items-center space-x-2');
            
            legendItem.append('div')
                .style('width', '12px')
                .style('height', '12px')
                .style('background-color', d => color(d[config.mapping.labelKey.value]))
                .style('border-radius', '2px');

            legendItem.append('span')
                .text(d => d[config.mapping.labelKey.value]);
        }
        
        // Function to create a Waffle Chart
        function createWaffleChart(config) {
            const containerId = 'waffleChartContainer';
            const legendId = 'waffleChartLegend';
            d3.select(`#${containerId}`).selectAll('*').remove();
            d3.select(`#${legendId}`).selectAll('*').remove();
            
            const totalSales = d3.sum(config.data, d => d[config.mapping.sizeKey.value]);
            const totalSquares = 100;
            let currentSquares = 0;
            let dataForWaffle = [];

            config.data.forEach(d => {
                const percentage = (d[config.mapping.sizeKey.value] / totalSales) * 100;
                const numSquares = Math.round(percentage / 100 * totalSquares);
                for (let i = 0; i < numSquares; i++) {
                    dataForWaffle.push(d);
                }
            });

            // Pad with empty squares if necessary
            while (dataForWaffle.length < totalSquares) {
                dataForWaffle.push(null);
            }

            const color = d3.scaleOrdinal()
                .domain(config.data.map(d => d[config.mapping.labelKey.value]))
                .range(config.mapping.colors);

            const chartTooltip = getOrCreateTooltip();

            // Create the waffle grid squares
            d3.select(`#${containerId}`)
                .selectAll('.waffle-square')
                .data(dataForWaffle)
                .join('div')
                .attr('class', 'waffle-square transition-colors duration-200 ease-in-out')
                .style('background-color', d => d ? color(d[config.mapping.labelKey.value]) : '#e2e8f0')
                .on("mouseover", function(event, d) {
                    if (d) {
                        d3.select(this).style('opacity', 0.8);
                        chartTooltip.style("display", "block")
                            .style("opacity", 1)
                            .html(generateTooltipContent(d, config.mapping.tooltipKeys))
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    }
                })
                .on("mouseout", function(d) {
                    d3.select(this).style('opacity', 1);
                    chartTooltip.style("opacity", 0).style("display", "none");
                });

            // Add a legend
            const legend = d3.select(`#${legendId}`);
            const legendItem = legend.selectAll('.legend-item')
                .data(config.data)
                .join('div')
                .attr('class', 'legend-item flex items-center space-x-2');
            
            legendItem.append('div')
                .style('width', '12px')
                .style('height', '12px')
                .style('background-color', d => color(d[config.mapping.labelKey.value]))
                .style('border-radius', '2px');

            legendItem.append('span')
                .text(d => `${d[config.mapping.labelKey.value]} (${d3.format(".1%")(d[config.mapping.sizeKey.value] / totalSales)})`);
        }

        // Function to create a Stacked Bar Chart
        function createStackedBarChart(config) {
            const containerId = 'stackedBarChartContainer';
            d3.select(`#${containerId}`).selectAll('*').remove();

            const container = document.getElementById(containerId);
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scaleBand()
                .domain(config.data.map(d => d[config.mapping.xKey.value]))
                .range([0, width])
                .padding(0.1);
            
            // Re-structure data for stacking
            const keys = [...new Set(config.data.map(d => d[config.mapping.seriesKey.value]))];
            const dataGrouped = d3.group(config.data, d => d[config.mapping.xKey.value]);
            const dataStacked = Array.from(dataGrouped, ([key, values]) => {
                const obj = {};
                obj[config.mapping.xKey.value] = key;
                values.forEach(v => {
                    obj[v[config.mapping.seriesKey.value]] = v[config.mapping.yKey.value];
                });
                return obj;
            });
            
            const stack = d3.stack()
                .keys(keys)
                .value((d, key) => d[key] || 0);
            
            const stackedData = stack(dataStacked);

            const y = d3.scaleLinear()
                .domain([0, d3.max(stackedData, d => d3.max(d, d => d[1]))])
                .nice()
                .range([height, 0]);
            
            const color = d3.scaleOrdinal()
                .domain(keys)
                .range(config.mapping.colors);

            const chartTooltip = getOrCreateTooltip();

            svg.append('g')
                .selectAll('g')
                .data(stackedData)
                .join('g')
                .attr('fill', d => color(d.key))
                .selectAll('rect')
                .data(d => d)
                .join('rect')
                .attr('x', d => x(d.data[config.mapping.xKey.value]))
                .attr('y', d => y(d[1]))
                .attr('height', d => y(d[0]) - y(d[1]))
                .attr('width', x.bandwidth())
                .on("mouseover", function(event, d) {
                    const seriesKey = d3.select(this.parentNode).datum().key;
                    const dataPoint = config.data.find(item => item[config.mapping.xKey.value] === d.data[config.mapping.xKey.value] && item[config.mapping.seriesKey.value] === seriesKey);
                    
                    chartTooltip.style("display", "block")
                        .style("opacity", 1)
                        .html(generateTooltipContent(dataPoint, config.mapping.tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0).style("display", "none");
                });

            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to create a Stacked Area Chart
        function createStackedAreaChart(config) {
            const containerId = 'stackedAreaChartContainer';
            d3.select(`#${containerId}`).selectAll('*').remove();

            const container = document.getElementById(containerId);
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Re-structure data for stacking
            const keys = [...new Set(config.data.map(d => d[config.mapping.seriesKey.value]))];
            const dataGroupedByX = d3.group(config.data, d => d[config.mapping.xKey.value]);
            const dataStacked = Array.from(dataGroupedByX, ([key, values]) => {
                const obj = {};
                obj[config.mapping.xKey.value] = key;
                values.forEach(v => {
                    obj[v[config.mapping.seriesKey.value]] = v[config.mapping.yKey.value];
                });
                return obj;
            });
            const dataNestedByProduct = d3.groups(config.data, d => d[config.mapping.seriesKey.value]);
            const dataGrouped = d3.group(config.data, d => d[config.mapping.xKey.value]);


            const x = d3.scalePoint()
                .domain(dataStacked.map(d => d[config.mapping.xKey.value]))
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(dataStacked, d => d3.sum(keys, key => d[key] || 0))])
                .nice()
                .range([height, 0]);

            const stack = d3.stack()
                .keys(keys)
                .value((d, key) => d[key] || 0);

            const stackedData = stack(dataStacked);

            const area = d3.area()
                .x(d => x(d.data[config.mapping.xKey.value]))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]))
                .curve(d3.curveCardinal);

            const color = d3.scaleOrdinal()
                .domain(keys)
                .range(config.mapping.colors);

            const chartTooltip = getOrCreateTooltip();

            // Add the stacked areas
            svg.selectAll("path")
                .data(stackedData)
                .join("path")
                .attr("fill", d => color(d.key))
                .attr("d", area)
                .style("opacity", 0.7);

            // Add the hover line and circles for better interaction
            const focus = svg.append("g")
                .style("display", "none");

            focus.append("line")
                .attr("class", "hover-line")
                .attr("y1", 0)
                .attr("y2", height)
                .attr("stroke", "black")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3");

            focus.selectAll("circle")
                .data(keys)
                .join("circle")
                .attr("r", 4)
                .attr("fill", d => color(d))
                .attr("stroke", "white")
                .attr("stroke-width", 1.5);

            // Add a transparent rectangle for mouse events
            svg.append("rect")
                .attr("class", "overlay")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .on("mouseover", () => {
                    focus.style("display", null);
                    chartTooltip.style("opacity", 1).style("display", "block");
                })
                .on("mouseout", () => {
                    focus.style("display", "none");
                    chartTooltip.style("opacity", 0).style("display", "none");
                })
                .on("mousemove", mousemove);

            // X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));

            function mousemove(event) {
                const [mx] = d3.pointer(event);
                
                // Find the closest month based on the mouse position
                const xDomain = x.domain();
                const xPoints = xDomain.map(d => x(d));
                const closestPointIndex = d3.bisectCenter(xPoints, mx);
                const closestMonth = xDomain[closestPointIndex];
                const xCoord = x(closestMonth);

                // Update the hover line position
                focus.select(".hover-line").attr("transform", `translate(${xCoord}, 0)`);
                
                // Filter the original data for the closest month
                const monthlyData = config.data.filter(d => d[config.mapping.xKey.value] === closestMonth);

                // Update the circles and tooltip
                focus.selectAll("circle")
                    .data(monthlyData, d => d[config.mapping.seriesKey.value])
                    .join("circle")
                    .attr("cx", xCoord)
                    .attr("cy", d => {
                        const y0 = stackedData.find(s => s.key === d[config.mapping.seriesKey.value]).find(d_ => d_.data[config.mapping.xKey.value] === closestMonth)[0];
                        const y1 = stackedData.find(s => s.key === d[config.mapping.seriesKey.value]).find(d_ => d_.data[config.mapping.xKey.value] === closestMonth)[1];
                        return y(y0 + (y1 - y0) / 2);
                    });
                
                // Build the tooltip content with all series data for the selected month
                let tooltipHtml = `<div><strong>${config.mapping.xKey.label}</strong>: ${closestMonth}</div>`;
                monthlyData.forEach(d => {
                    tooltipHtml += `<div><strong>${d[config.mapping.seriesKey.value]}</strong>: ${formatNumber(d[config.mapping.yKey.value], config.mapping.tooltipKeys.find(k => k.value === "sales").format)}</div>`;
                });
                
                chartTooltip.html(tooltipHtml)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            }
        }

        // Function to create a Grouped Bar Chart
        function createGroupedBarChart(config) {
            const containerId = 'groupedBarChartContainer';
            d3.select(`#${containerId}`).selectAll('*').remove();
            
            const container = document.getElementById(containerId);
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Get keys for grouping
            const keys = [...new Set(config.data.map(d => d[config.mapping.seriesKey.value]))];
            
            const x0 = d3.scaleBand()
                .domain(config.data.map(d => d[config.mapping.xKey.value]))
                .range([0, width])
                .padding(0.1);

            const x1 = d3.scaleBand()
                .domain(keys)
                .range([0, x0.bandwidth()])
                .padding(0.05);

            const y = d3.scaleLinear()
                .domain([0, d3.max(config.data, d => d[config.mapping.yKey.value])])
                .nice()
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(keys)
                .range(config.mapping.colors);

            const chartTooltip = getOrCreateTooltip();

            // Group data by month
            const dataGrouped = d3.group(config.data, d => d[config.mapping.xKey.value]);

            svg.append('g')
                .selectAll('g')
                .data(dataGrouped)
                .join('g')
                .attr('transform', d => `translate(${x0(d[0])},0)`)
                .selectAll('rect')
                .data(d => d[1])
                .join('rect')
                .attr('x', d => x1(d[config.mapping.seriesKey.value]))
                .attr('y', d => y(d[config.mapping.yKey.value]))
                .attr('width', x1.bandwidth())
                .attr('height', d => height - y(d[config.mapping.yKey.value]))
                .attr('fill', d => color(d[config.mapping.seriesKey.value]))
                .on("mouseover", function(event, d) {
                    chartTooltip.style("display", "block")
                        .style("opacity", 1)
                        .html(generateTooltipContent(d, config.mapping.tooltipKeys))
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    chartTooltip.style("opacity", 0).style("display", "none");
                });

            // Add X-axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0));
            
            // Add Y-axis
            svg.append('g')
                .call(d3.axisLeft(y));
        }

        // Function to render charts for a specific section
        function renderChartsForSection(sectionId) {
            // Get the container for the active section
            const activeSection = document.getElementById(sectionId);
            if (!activeSection) return;

            // Render charts based on the section
            if (sectionId === 'section1') {
                createBarChart(chartConfig1);
                createDotPlot(chartConfig1);
            } else if (sectionId === 'section2') {
                createPieChart(chartConfig2);
                createWaffleChart(chartConfig2);
            } else if (sectionId === 'section3') {
                createStackedBarChart(chartConfig3);
                createStackedAreaChart(chartConfig3);
                createGroupedBarChart(chartConfig3);
            }
        }

        // Setup the tab buttons functionality
        function setupTabs() {
            const buttons = document.querySelectorAll('.tab-button');
            const sections = document.querySelectorAll('.tab-content');

            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons and hide all sections
                    buttons.forEach(btn => btn.classList.remove('active-button', 'bg-blue-600', 'text-white'));
                    buttons.forEach(btn => btn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300'));
                    sections.forEach(sec => sec.classList.add('hidden'));

                    // Add active class to the clicked button and show the target section
                    button.classList.add('active-button', 'bg-blue-600', 'text-white');
                    button.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
                    const targetSection = document.getElementById(button.dataset.target);
                    if (targetSection) {
                        targetSection.classList.remove('hidden');
                        // Render the charts for the newly active section
                        renderChartsForSection(button.dataset.target);
                    }
                });
            });
            // Click the first button on initial load
            document.getElementById('button1').click();
        }

        // Function to toggle the display of the JSON mapping
        function toggleMapping(wrapperId) {
            const wrapper = document.getElementById(wrapperId);
            wrapper.classList.toggle('hidden');
        }

        // Redraw charts on window resize to ensure responsiveness
        function handleResize() {
            const activeTab = document.querySelector('.tab-content:not(.hidden)');
            if (activeTab) {
                renderChartsForSection(activeTab.id);
            }
        }

        // Initialize the app on window load
        window.onload = function() {
            const mappingJson1 = JSON.stringify(chartConfig1.mapping, null, 2);
            const mappingJson2 = JSON.stringify(chartConfig2.mapping, null, 2);
            const mappingJson3 = JSON.stringify(chartConfig3.mapping, null, 2);

            document.getElementById('mapping-display-1').textContent = mappingJson1;
            document.getElementById('mapping-display-2').textContent = mappingJson2;
            document.getElementById('mapping-display-3').textContent = mappingJson3;

            setupTabs();
            // Add event listener for window resizing
            window.addEventListener('resize', handleResize);
        };
    </script>
</body>
</html>
